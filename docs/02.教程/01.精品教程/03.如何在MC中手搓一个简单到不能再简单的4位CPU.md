---
title: 如何在MC中手搓一个简单到不能再简单的4位CPU
date: 2022-10-16 19:55:04
permalink: /pages/7a38d1/
categories:
  - 教程
  - 精品教程
tags:
  - 
---
# 如何在MC中手搓一个简单到不能再简单的4位CPU

## 1.总述

首先因为我个人的知识量受限，下面讨论的指令集都是基于RISC的。

与CISC指令集架构的处理器可以直接在内存（ram）中进行操作不同，RISC指令集架构的处理器普遍只能在寄存器中进行各种操作。指令格式固定且RISC处理器的单条指令一般只涉及很少的操作，也就意味着RISC处理器的时钟周期更容易提高，对于我这种对cpu了解不深的人来说 ***设计起来也更容易***。

<!-- more -->

首先，为了让我们的cpu在设计和制作上更简单，我们把我们的指令集长度定在8bit。其中，前4bit定义为操作码，后4bit定义为地址码。寄存器方面，因为我们设计的cpu对用户可见的寄存器很少，只有3个，所以我们可以将寄存器地址包含在操作码中.且ALU只支持加一种算数功能和与或非三种基本逻辑运算，且不涉及中断系统 ~~（甚至没有条件转移指令）~~，以便尽量缩减指令字长和降低设计难度。

然后，在结构上，我们选择将指令和数据分开储存的哈佛结构。并将alu位宽定在4bit ~~（当然这个其实可以随便）~~

## 2.指令集

***——意味着0000（0000在这个cpu上不可用）***

***0000意味着可以写0001-1111的任意数字***

- [ ] 操作码  地址码  含义
- [ ] 0001     0000    将ram中对应地址的数据写入寄存器0
- [ ] 0010     0000    将ram中对应地址的数据写入寄存器1
- [ ] 0011     ——     将寄存器0与寄存器1的数据相加后写入寄存器2
- [ ] 0100     ——     将寄存器0与寄存器1的数据与运算后写入寄存器2
- [ ] 0101     ——     将寄存器0与寄存器1的数据或运算后写入寄存器2
- [ ] 0110     ——     将寄存器0的数据非运算后写入寄存器2
- [ ] 0111     0000    将寄存器2的数据写入ram中对应地址
- [ ] 1000     0000    跳转到指定地址
- [ ] 1001     ——     停机

#### 使用例：

假定ram：0001中数据为0010，0010中数据为0001，完成操作：0010-0001并将结果写入0101

- [ ] 0001     0001     

- [ ] 0110     0000

- [ ] 0111     0011

- [ ] 0001     0011

- [ ] 0010     0010

- [ ] 0011     0000

- [ ] 0111     0100

- [ ] 0001     0100

- [ ] 0010     0001

- [ ] 0011     0000

- [ ] 0111     0101

- [ ] 1001     0000

  

## 3.总体结构

### 1.控制单元

在我们准备制作的cpu上,控制单元由指令储存器x1(可为ram也可为rom),指令译码器x1,地址译码器x2,程序计数器x1组成

(由于我本人只熟悉机械电路,所以下面的部件均由活塞粘液块等典型械电方块构成,当然用红石构成的固定模块也可以做,设计上完全通用)

#### 1.指令储存器

为了方便制作,我们将使用rom搭建指令储存器

由于指令字长中,留给地址的只有4bit,所以我们的程序储存器最多只能有16x8bit,也就是16bytes容量

![2021-09-29_02.14.51](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2021-09-29_02.13j0nkrl0dpc.webp)

(上图为一个2x24bit的可移动储存单元)

因为rom只需要读取而不需要写入,所以我们可以直接塞一排粘性活塞,粘性活塞朝下,然后放一个红石块在活塞头上.这样就搭建好了1bit的rom单元.(下图)![2022-10-16_12.14.16](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_12.2rmgw7auq2a0.webp)接着我们就可以直接堆叠这种储存单元至8bit,然后每8bit一组,连接好地址线.这样就搭好了1byte的储存单元(下图).![2022-10-16_12.15.38](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_12.7guqdhbbj4k0.webp)最后堆叠1byte的储存单元,并统一接入到一条8bit宽的数据总线即可(图1.4).当然,mc中铁轨总线有一个距离上限,那么我们直接用一个观察者方块充当中继器即可(下图)![2022-10-16_12.16.23](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_12.3kur5bj53d80.webp)

使用时将上方铁轨线作为寻址线接入译码器,下方铁轨线作为数据线接入需要数据的地方就行 ~~(废话)~~

![2022-10-16_13.09.24](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_13.7c88a2k2sk40.webp)

输出端做成这样保证信号可以常亮（省去了寄存器）

#### 2.译码器

由于本cpu非常简单,所以普遍只需要4位二转十译码器即可

这里因为这玩意很简单且通用，所以没必要讲译码器的底层逻辑，我就省略掉直接讲制作罢

首先我们建造一条总线（粘性活塞+红石块），并在总线中间的空隙放向上的粘性活塞（位数随便，我这里因为指令集里面都是4bit一组，就只做了4bit。）![2022-10-16_12.53.23](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_12.5szuiv9f2zs0.webp)

然后，我们在为1的位置把方块摆成这个样子（活塞都是粘性）

![2022-10-16_12.53.55](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_12.5wwng8kk0vo0.webp)

在0的位置把方块摆成这个样子![2022-10-16_12.53.38](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_12.34qzxgy5n4s0.webp)

然后，根据mc特有时序系统，在总线的输入端照着下面的图做就行

![2022-10-16_12.58.45](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_12.43wcx7xrrou0.webp)

![2022-10-16_13.06.15](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_13.7hnac6x7r0g0.webp)

那个蓝白黄的方块可以是任意一种陶瓦，但其他方块都不行

下面的是数据输入线路，上面则是输出线路，对应那一排的二进制数字

我们上面做的译码器是十分灵活的，你只需要知道怎么做0和1对应的译码单元，你可以自己决定那一排需要译的数字，当然你也可以决定哪里是低位那里是高位。

#### 3.程序计数器

程序计数器是一个可以进行累加的计数器，在我们这个单周期cpu中，他每一个指令周期都会进行一次+1的操作（因为我们的cpu每周期只执行一条指令）

我们在这里使用t触发器来制作一个程序计数器（根据输入信号t取值的不同，具有保持和翻转功能的触发器，t=0时保持状态不变，t=1时一定翻转）

下图就是一个很典型的mc中基于械电实现的t触发器

![2022-10-16_13.17.40](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_13.78njcng46y40.webp)

然后我们根据高低位排列4个t触发器，就得到了一个4位程序计数器（下图）

这个程序计数器从右为低位，左为高位（可以镜像反转建造来改变高低位方向），使用时激活最低位就行。输出端为那些红石块。

![2022-10-16_13.20.23](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_13.5ywfjgc5sv80.webp)

#### 4.组装CU

如下图（不一定要这样摆，数据方向到位就行）

<img src="https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/cu结构.6rfszem2u2s0.webp" alt="cu结构" style="zoom: 80%;" />

### 2.执行单元

我们的cpu的执行单元由数据存储器(RAM)，算数逻辑单元（ALU）组成，其中，ALU需要能执行简单的整数加法和与或非运算

#### 1.ALU

##### 1.加法器

想要制作一个加法器，首先我们得知道他由哪些逻辑门组成

![eaf81a4c510fd9f953e7a843272dd42a2834a42c](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/eaf81a4c510fd9f953e7a843272dd42a2834a42c.7hr84kdw20g0.webp)

参考上面这张百度百科上的全加器逻辑电路图，我们可以看到异或门，与门和或门。在mc械电逻辑门中，他们长这个样子

<img src="https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_13.3dbz7lxq1v40.webp" alt="2022-10-16_13.48.10" style="zoom:50%;" />



我们按照百度百科上的逻辑图排列这些逻辑门，就可以得到一个最普通的全加器，但我们在这里要使用的并不是这种十分简单的全加器。为了让执行单元的速度能跟得上前端控制单元的速度，我们要采用一种被称之为“超前进位加法器”的更先进的加法器，并对其进行一点改进，让它变成mc特有的更先进的“进位取消加法器（CCA）”

超前进位加法器将普通加法器的第二个异或门的相关电路进行了重构，将其换成了一种被称之为“进位链”的结构，这种结构有如下功能：

当该位全加器有输入时，打开向下一位进位的开关，当该位全加器有进位信号时，也就是说该位全加器两个输入端都启动时。向下一位传递进位信号。这样可以让原本加法器中的一位一位进行的串行进位改为多位同时进行的并行进位。在现实世界中，进位链并不是无延时的，但mc不是现实，如果我们用一些mc的特性，做一个无延时进位链。那么无论加法器有多少位，延时都不会变化。所以在mc中，运算位数越多，cca相对于普通加法器的速度优势就会越大

这里我不会做教程，因为其中涉及了较多mc特有的延时计算，对不玩mc红石的人来说较难理解。所以我在下文会直接贴出一个我做的械电cca的存档链接

下图就是一个基于械电的cca（被我拆掉了移动线路）

![cca1](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/cca1.2fgaczu10ib.webp)

下图所示是cca的两个输入端口，上下各4bit（需要同时输入）

![cca2](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/cca2.34a9bvqacas0.webp)

下图为cca的输入端，一排共4bit

![cca3](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/cca3.63r0atw6rn40.webp)

存档链接：https://pan.baidu.com/s/13B1ZUFozAzlawCkShg-VPw 提取码：1145

##### 2.逻辑单元

1.与

上面讲加法器的时候有一张图涉及到了与门，直接那样中间隔2格横向堆叠4位就行，当然，上下左右放方向随便

![2022-10-16_14.50.17](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_14.16n62mj3xae8.webp)

2.或

上面讲加法器的时候有一张图涉及到了或门，直接那样中间隔2格横向堆叠4位就行，当然，上下左右放方向随便

![2022-10-16_14.51.08](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_14.2up5540miuq0.webp)

3非

非门是一种输入端和输出端信号必相反的逻辑门，如下图（已经堆了4位了）

![2022-10-16_14.52.06](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_14.jmeaqc4x9ig.webp)

#### 4.组装alu

本来alu其实是基于一个加法器然后接线分割逻辑来实现多种运算的，但因为mc里面用械电接线比较复杂，所以我们干脆就做一堆独立的运算单元，然后把他们挂在一个总线上。反正mc里面电路不费电，那我们就让他在运行时启动所有运算单元，但输出时选择一个需要的部分进行输出。简单又高效~~（懒）~~

组装逻辑电路如下图

![alu](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/alu.2w6pglilvw80.webp)

### 2.寄存器与数据储存器

本来在现实中这俩不是一个东西，但在mc里面拉不开差距，所以一般情况下这俩在mc里面就是一个东西，干脆就放一块做教程

在mc的械电领域，储存器储存数据一般是依靠活塞产生的方块位移实现的

如下图，下图既为一个械电ram储存单元，当面朝我们的活塞被推下一格，既是代表储存了1，而当下面的活塞把面朝我们的活塞推回去复位，则代表了储存0。

ram在每一次写入新数据之前会自擦除之前的数据

每个ram单元出了输入输出端外，还有两条控制线路，一条控制写入（当它关闭时，输入总线不与ram产生信息交互。当他开启时，清空一次ram，并允许总线与ram产生信息交互），另一条控制读取

![2022-10-16_15.22.56](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_15.1ajod613fy80.webp)

而当我们完成了其周边控制电路后，就变成了下图的样子，老规矩，红石块那里是输出端，接入到数据总线上就行，与rom不同的是，上面还有个输入端，当然输入端也得接入数据总线。

至于控制线路，到时候堆叠15格ram并接入数据总线后起来后把控制线路接入到控制部分的ram地址译码器就行

![2022-10-16_15.23.00](https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/2022-10-16_15.2p8lwulqg9k0.webp)

如果懒得做寄存器的话，直接拿上面的ram单元当寄存器也行，当然，你得保证每bit同时输出给alu

#### 3.组装执行部分

数据方向如下图，只要保证数据是这样流的就行

<img src="https://cdn.staticaly.com/gh/CQNU-PC/pc-img@master/粘液块sdark/如何在MC中手搓一个简单到不能再简单的4位CPU/eu.68bn1nut5sc0.webp" style="zoom: 67%;" />

### 3.连接执行单元与控制单元

*这一部分没有通用解，必须按照需要完成的操作和mc的时序来。下面我会把每一个指令分解为几个微操作，照着接线就行*

- [ ] 0001     0000    将ram中对应地址的数据写入寄存器0                      **微操作：打开寄存器0写入端口→打开ram对应地址译码器的结果输出开关（读取部分，用于读取ram数据，当这个打开时，控制写入的开关关闭）**
- [ ] 0010     0000    将ram中对应地址的数据写入寄存器1                      **微操作：打开寄存器1写入端口→打开ram对应地址译码器的结果输出开关（读取部分，用于读取ram数据，当这个打开时，控制写入的开关关闭）**
- [ ] 0011     ——     将寄存器0与寄存器1的数据相加后写入寄存器2      **微操作： 打开寄存器0读取端口→打开寄存器1读取端口（然后等待加法器出确切结果）→打开加法器输入端上的与门第二个输入端（第一个接在加法器输出端上）→打开寄存器2输入接口（当然你可以把这个寄存器设定为有新数据输入就自动清理掉之前的数据）**
- [ ] 0100     ——     将寄存器0与寄存器1的数据与运算后写入寄存器2   **微操作： 打开寄存器0读取端口→打开寄存器1读取端口（然后等待与运算器出确切结果）→打开与运算器输入端上的与门第二个输入端（第一个接在与运算器输出端上）→打开寄存器2输入接口（当然你可以把这个寄存器设定为有新数据输入就自动清理掉之前的数据）**
- [ ] 0101     ——     将寄存器0与寄存器1的数据或运算后写入寄存器2   **微操作： 打开寄存器0读取端口→打开寄存器1读取端口（然后等待或运算器出确切结果）→打开与运算器输入端上的或门第二个输入端（第一个接在或运算器输出端上）→打开寄存器2输入接口（当然你可以把这个寄存器设定为有新数据输入就自动清理掉之前的数据）**
- [ ] 0110     ——     将寄存器0的数据非运算后写入寄存器2                     **微操作： 打开寄存器0读取端口并等待非运算器出确切结果（非运算器只接受寄存器0的数据）→打开非运算器输入端上的或门第二个输入端（第一个接在非运算器输出端上）→打开寄存器2输入接口（当然你可以把这个寄存器设定为有新数据输入就自动清理掉之前的数据）**
- [ ] 0111     0000    将寄存器2的数据写入ram中对应地址                        **微操作：打开ram对应地址译码器的结果输出开关（写入部分，用于给ram写入数据，当这个打开时，控制读取的开关关闭）→打开寄存器2的读取端开关**
- [ ] 1000     0000    跳转到指定地址                                                             备注：rom在和ram地址译码器之间，引出一条数据总线接入到程序计数器上，并且中间安装与门作为开关                                         **微操作：打开rom与地址译码器之间的与门开关，复位程序计数器（没有做流水线，所以不用清空其他寄存器）→等待程序计数器接受新地址→关闭每周期让程序计数器+1的信号（也就是时钟），使下周期程序计数器不+1（仅一周期）**
- [ ] 1001     ——     停机                                                                                **微操作：清除指令寄存器（但这个u好像没有2333）→关闭时钟**

## 4.尾声

这个教程写的很不详细，更适合已经学完了计组想练练手的大佬，但就算没学机组，应该也能大概搞懂cpu是怎么运行的。而且出于我自己知识水平的问题，很可能会有纰漏，也希望dalao指正（如果意见比较多的话，我会参考了并且对这篇文章进行修改）

如果有人看了这篇文章还有不懂或者对简单的流水线处理器感兴趣，也可以加我的[QQ：3047808825](https://qm.qq.com/cgi-bin/qm/qr?k=6Jpq7F_NwWlsRV_052qiXxXTROQdpY33&noverify=0&personal_qrcode_source=4)。当然，其实我也只是一个爱好者的程度，真想学东西还得自己找书看，这里入门的话推荐唐朔飞的《计算机组成原理》，也就是我们学校的计算机的教材。如果有更深层次的计算机学习需求，可以看看David A. Patterson和John L. Hennessy两位的《计算机体系结构：量化研究方法》

哦对，结尾了我还是给自己引一波流，当然大伙也可以看看mc中的械电处理器是怎么运行的

全球第一个基于mc的可移动cpu，4位（视频里还没做移动机构）：[BV1ME411w7AJ](https://www.bilibili.com/video/BV1ME411w7AJ/)（b站）

两级流水线的8位可移动cpu：[BV1vM4y1M7MW](https://www.bilibili.com/video/BV1vM4y1M7MW/)（b站）
